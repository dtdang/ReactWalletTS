"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Publisher = exports.IPublisher = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const logger_1 = require("@walletconnect/logger");
const utils_1 = require("@walletconnect/utils");
const jsonrpc_types_1 = require("@walletconnect/jsonrpc-types");
const constants_1 = require("../constants");
class IPublisher extends jsonrpc_types_1.IEvents {
    constructor(relayer, logger) {
        super();
        this.relayer = relayer;
        this.logger = logger;
    }
}
exports.IPublisher = IPublisher;
class Publisher extends IPublisher {
    constructor(relayer, logger) {
        super(relayer, logger);
        this.relayer = relayer;
        this.logger = logger;
        this.events = new events_1.EventEmitter();
        this.name = constants_1.PUBLISHER_CONTEXT;
        this.queue = new Map();
        this.relayer = relayer;
        this.logger = logger_1.generateChildLogger(logger, this.name);
        this.registerEventListeners();
    }
    get context() {
        return logger_1.getLoggerContext(this.logger);
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            yield this.initialize();
        });
    }
    publish(topic, payload, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Publishing Payload`);
            this.logger.trace({ type: "method", method: "publish", params: { topic, payload, opts } });
            try {
                const ttl = (opts === null || opts === void 0 ? void 0 : opts.ttl) || constants_1.PUBLISHER_DEFAULT_TTL;
                const relay = utils_1.getRelayProtocolName(opts);
                const prompt = (opts === null || opts === void 0 ? void 0 : opts.prompt) || false;
                const params = { topic, payload, opts: { ttl, relay, prompt } };
                this.queue.set(payload.id, params);
                const message = yield this.relayer.encoder.encode(topic, payload);
                yield this.rpcPublish(topic, message, ttl, relay, prompt);
                yield this.onPublish(payload.id, params);
                this.logger.debug(`Successfully Published Payload`);
                this.logger.trace({ type: "method", method: "publish", params: { topic, payload, opts } });
            }
            catch (e) {
                this.logger.debug(`Failed to Publish Payload`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
        });
    }
    rpcPublish(topic, message, ttl, relay, prompt) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const api = utils_1.getRelayProtocolApi(relay.protocol);
            const request = {
                method: api.publish,
                params: {
                    topic,
                    message,
                    ttl,
                    prompt,
                },
            };
            if (typeof ((_a = request.params) === null || _a === void 0 ? void 0 : _a.prompt) === "undefined") {
                (_b = request.params) === null || _b === void 0 ? true : delete _b.prompt;
            }
            this.logger.debug(`Outgoing Relay Payload`);
            this.logger.trace({ type: "payload", direction: "outgoing", request });
            return this.relayer.provider.request(request);
        });
    }
    onPublish(id, params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.queue.delete(id);
        });
    }
    checkQueue() {
        this.queue.forEach((params) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload, opts: { ttl, relay }, } = params;
            const message = yield this.relayer.encoder.encode(topic, payload);
            yield this.rpcPublish(topic, message, ttl, relay);
            yield this.onPublish(payload.id, params);
        }));
    }
    registerEventListeners() {
        this.relayer.heartbeat.on(constants_1.HEARTBEAT_EVENTS.pulse, () => {
            this.checkQueue();
        });
    }
}
exports.Publisher = Publisher;
//# sourceMappingURL=publisher.js.map