"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HeartBeat = void 0;
const tslib_1 = require("tslib");
const pino_1 = tslib_1.__importDefault(require("pino"));
const events_1 = require("events");
const types_1 = require("@walletconnect/types");
const constants_1 = require("../constants");
const logger_1 = require("@walletconnect/logger");
const utils_1 = require("@walletconnect/utils");
class HeartBeat extends types_1.IHeartBeat {
    constructor(opts) {
        super(opts);
        this.events = new events_1.EventEmitter();
        this.interval = constants_1.HEARTBEAT_INTERVAL;
        this.name = constants_1.HEARTBEAT_CONTEXT;
        this.logger =
            typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== "undefined" && typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== "string"
                ? logger_1.generateChildLogger(opts.logger, this.name)
                : pino_1.default(logger_1.getDefaultLoggerOptions({ level: (opts === null || opts === void 0 ? void 0 : opts.logger) || constants_1.HEARTBEAT_DEFAULT_LOGGER }));
        this.interval = (opts === null || opts === void 0 ? void 0 : opts.interval) || constants_1.HEARTBEAT_INTERVAL;
    }
    static init(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const heartbeat = new HeartBeat(opts);
            yield heartbeat.init();
            return heartbeat;
        });
    }
    get context() {
        return logger_1.getLoggerContext(this.logger);
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            yield this.initialize();
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            setInterval(() => this.pulse(), utils_1.toMiliseconds(this.interval));
            this.logger.trace(`Initialized`);
        });
    }
    pulse() {
        this.events.emit(constants_1.HEARTBEAT_EVENTS.pulse);
    }
}
exports.HeartBeat = HeartBeat;
//# sourceMappingURL=heartbeat.js.map