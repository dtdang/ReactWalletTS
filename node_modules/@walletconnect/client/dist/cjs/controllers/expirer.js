"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Expirer = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const types_1 = require("@walletconnect/types");
const logger_1 = require("@walletconnect/logger");
const utils_1 = require("@walletconnect/utils");
const constants_1 = require("../constants");
class Expirer extends types_1.IExpirer {
    constructor(client, logger) {
        super(client, logger);
        this.client = client;
        this.logger = logger;
        this.expirations = new Map();
        this.events = new events_1.EventEmitter();
        this.name = constants_1.EXPIRER_CONTEXT;
        this.cached = [];
        this.client;
        this.logger = logger_1.generateChildLogger(logger, this.name);
        this.registerEventListeners();
    }
    get context() {
        return logger_1.getLoggerContext(this.logger);
    }
    get length() {
        return this.expirations.size;
    }
    get topics() {
        return Array.from(this.expirations.keys());
    }
    get values() {
        return Array.from(this.expirations.values());
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            yield this.initialize();
        });
    }
    has(topic) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const expiration = this.getExpiration(topic);
                return typeof expiration !== "undefined";
            }
            catch (e) {
                return false;
            }
        });
    }
    set(topic, expiration) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isInitialized();
            this.expirations.set(topic, expiration);
            this.checkExpiry(topic, expiration);
            this.events.emit(constants_1.EXPIRER_EVENTS.created, {
                topic,
                expiration,
            });
        });
    }
    get(topic) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isInitialized();
            return this.getExpiration(topic);
        });
    }
    del(topic) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isInitialized();
            const expiration = this.getExpiration(topic);
            this.expirations.delete(topic);
            this.events.emit(constants_1.EXPIRER_EVENTS.deleted, {
                topic,
                expiration,
            });
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    persist() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.client.storage.setSequenceStore(this.context, this.values);
            this.events.emit(constants_1.EXPIRER_EVENTS.sync);
        });
    }
    restore() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const persisted = yield this.client.storage.getSequenceStore(this.context);
                if (typeof persisted === "undefined")
                    return;
                if (!persisted.length)
                    return;
                if (this.expirations.size) {
                    const error = utils_1.ERROR.RESTORE_WILL_OVERRIDE.format({
                        context: utils_1.formatMessageContext(this.context),
                    });
                    this.logger.error(error.message);
                    throw new Error(error.message);
                }
                this.cached = persisted;
                this.logger.debug(`Successfully Restored expirations for ${utils_1.formatMessageContext(this.context)}`);
                this.logger.trace({ type: "method", method: "restore", expirations: this.values });
            }
            catch (e) {
                this.logger.debug(`Failed to Restore expirations for ${utils_1.formatMessageContext(this.context)}`);
                this.logger.error(e);
            }
        });
    }
    initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.restore();
            this.reset();
            this.onInit();
        });
    }
    reset() {
        this.cached.forEach(expiration => this.expirations.set(expiration.topic, expiration));
    }
    onInit() {
        this.cached = [];
        this.events.emit(constants_1.EXPIRER_EVENTS.init);
    }
    isInitialized() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.cached.length)
                return;
            return new Promise(resolve => {
                this.events.once(constants_1.EXPIRER_EVENTS.init, () => resolve());
            });
        });
    }
    getExpiration(topic) {
        const expiration = this.expirations.get(topic);
        if (!expiration) {
            const error = utils_1.ERROR.NO_MATCHING_ID.format({
                context: utils_1.formatMessageContext(this.context),
                topic,
            });
            throw new Error(error.message);
        }
        return expiration;
    }
    checkExpiry(topic, expiration) {
        const { expiry } = expiration;
        const msToTimeout = utils_1.toMiliseconds(expiry) - Date.now();
        if (msToTimeout <= 0)
            this.expire(topic, expiration);
    }
    expire(topic, expiration) {
        this.expirations.delete(topic);
        this.events.emit(constants_1.EXPIRER_EVENTS.expired, {
            topic,
            expiration,
        });
    }
    checkExpirations() {
        this.expirations.forEach((expiration, topic) => this.checkExpiry(topic, expiration));
    }
    registerEventListeners() {
        this.client.heartbeat.on(constants_1.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations());
        this.events.on(constants_1.EXPIRER_EVENTS.created, (createdEvent) => {
            const eventName = constants_1.EXPIRER_EVENTS.created;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: createdEvent });
            this.persist();
        });
        this.events.on(constants_1.EXPIRER_EVENTS.expired, (expiredEvent) => {
            const eventName = constants_1.EXPIRER_EVENTS.expired;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: expiredEvent });
            this.persist();
        });
        this.events.on(constants_1.EXPIRER_EVENTS.deleted, (deletedEvent) => {
            const eventName = constants_1.EXPIRER_EVENTS.deleted;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: deletedEvent });
            this.persist();
        });
    }
}
exports.Expirer = Expirer;
//# sourceMappingURL=expirer.js.map