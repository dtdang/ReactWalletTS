"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Subscriber = exports.SubscriberTopicMap = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const types_1 = require("@walletconnect/types");
const utils_1 = require("@walletconnect/utils");
const logger_1 = require("@walletconnect/logger");
const constants_1 = require("../constants");
class SubscriberTopicMap {
    constructor() {
        this.map = new Map();
    }
    get topics() {
        return Array.from(this.map.keys());
    }
    set(topic, id) {
        const ids = this.get(topic);
        if (this.exists(topic, id))
            return;
        this.map.set(topic, [...ids, id]);
    }
    get(topic) {
        const ids = this.map.get(topic);
        return ids || [];
    }
    exists(topic, id) {
        const ids = this.get(topic);
        return ids.includes(id);
    }
    delete(topic, id) {
        if (typeof id === "undefined") {
            this.map.delete(topic);
            return;
        }
        if (!this.map.has(topic))
            return;
        const ids = this.get(topic);
        if (!this.exists(topic, id))
            return;
        const remaining = ids.filter(x => x !== id);
        if (!remaining.length) {
            this.map.delete(topic);
            return;
        }
        this.map.set(topic, remaining);
    }
    clear() {
        this.map.clear();
    }
}
exports.SubscriberTopicMap = SubscriberTopicMap;
class Subscriber extends types_1.ISubscriber {
    constructor(relayer, logger) {
        super(relayer, logger);
        this.relayer = relayer;
        this.logger = logger;
        this.subscriptions = new Map();
        this.topicMap = new SubscriberTopicMap();
        this.events = new events_1.EventEmitter();
        this.name = constants_1.SUBSCRIBER_CONTEXT;
        this.pending = new Map();
        this.cached = [];
        this.relayer = relayer;
        this.logger = logger_1.generateChildLogger(logger, this.name);
        this.registerEventListeners();
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            yield this.initialize();
        });
    }
    get context() {
        return logger_1.getLoggerContext(this.logger);
    }
    get length() {
        return this.subscriptions.size;
    }
    get ids() {
        return Array.from(this.subscriptions.keys());
    }
    get values() {
        return Array.from(this.subscriptions.values());
    }
    get topics() {
        return this.topicMap.topics;
    }
    subscribe(topic, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Subscribing Topic`);
            this.logger.trace({ type: "method", method: "subscribe", params: { topic, opts } });
            try {
                const relay = utils_1.getRelayProtocolName(opts);
                const params = { topic, relay };
                this.pending.set(topic, params);
                const id = yield this.rpcSubscribe(topic, relay);
                yield this.onSubscribe(id, params);
                this.logger.debug(`Successfully Subscribed Topic`);
                this.logger.trace({ type: "method", method: "subscribe", params: { topic, opts } });
                return id;
            }
            catch (e) {
                this.logger.debug(`Failed to Subscribe Topic`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    unsubscribe(topic, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (typeof (opts === null || opts === void 0 ? void 0 : opts.id) !== "undefined") {
                yield this.unsubscribeById(topic, opts.id, opts);
            }
            else {
                yield this.unsubscribeByTopic(topic, opts);
            }
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    enable() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.cached.length)
                return;
            this.onEnable();
        });
    }
    disable() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.cached.length)
                return;
            this.onDisable();
        });
    }
    hasSubscription(id, topic) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isEnabled();
            let result = false;
            try {
                const subscription = yield this.getSubscription(id);
                result = subscription.topic === topic;
            }
            catch (e) {
            }
            return result;
        });
    }
    onEnable() {
        this.cached = [];
        this.events.emit(constants_1.SUBSCRIBER_EVENTS.enabled);
    }
    onDisable() {
        this.cached = this.values;
        this.subscriptions.clear();
        this.topicMap.clear();
        this.events.emit(constants_1.SUBSCRIBER_EVENTS.disabled);
    }
    unsubscribeByTopic(topic, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const ids = this.topicMap.get(topic);
            yield Promise.all(ids.map((id) => tslib_1.__awaiter(this, void 0, void 0, function* () { return yield this.unsubscribeById(topic, id, opts); })));
        });
    }
    unsubscribeById(topic, id, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Unsubscribing Topic`);
            this.logger.trace({ type: "method", method: "unsubscribe", params: { topic, id, opts } });
            try {
                const relay = utils_1.getRelayProtocolName(opts);
                yield this.rpcUnsubscribe(topic, id, relay);
                const reason = utils_1.ERROR.DELETED.format({ context: utils_1.formatMessageContext(this.context) });
                yield this.onUnsubscribe(topic, id, reason);
                this.logger.debug(`Successfully Unsubscribed Topic`);
                this.logger.trace({ type: "method", method: "unsubscribe", params: { topic, id, opts } });
            }
            catch (e) {
                this.logger.debug(`Failed to Unsubscribe Topic`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    rpcSubscribe(topic, relay) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const api = utils_1.getRelayProtocolApi(relay.protocol);
            const request = {
                method: api.subscribe,
                params: {
                    topic,
                },
            };
            this.logger.debug(`Outgoing Relay Payload`);
            this.logger.trace({ type: "payload", direction: "outgoing", request });
            return this.relayer.provider.request(request);
        });
    }
    rpcUnsubscribe(topic, id, relay) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const api = utils_1.getRelayProtocolApi(relay.protocol);
            const request = {
                method: api.unsubscribe,
                params: {
                    topic,
                    id,
                },
            };
            this.logger.debug(`Outgoing Relay Payload`);
            this.logger.trace({ type: "payload", direction: "outgoing", request });
            return this.relayer.provider.request(request);
        });
    }
    onSubscribe(id, params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.setSubscription(id, Object.assign(Object.assign({}, params), { id }));
            this.pending.delete(params.topic);
        });
    }
    onResubscribe(id, params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.addSubscription(id, Object.assign(Object.assign({}, params), { id }));
            this.pending.delete(params.topic);
        });
    }
    onUnsubscribe(topic, id, reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.events.removeAllListeners(id);
            if (yield this.hasSubscription(id, topic)) {
                yield this.deleteSubscription(id, reason);
            }
            yield this.relayer.history.delete(topic);
        });
    }
    setSubscription(id, subscription) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isEnabled();
            if (this.subscriptions.has(id))
                return;
            this.logger.debug(`Setting subscription`);
            this.logger.trace({ type: "method", method: "setSubscription", id, subscription });
            yield this.addSubscription(id, subscription);
        });
    }
    addSubscription(id, subscription) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.subscriptions.set(id, Object.assign({}, subscription));
            this.topicMap.set(subscription.topic, id);
            this.events.emit(constants_1.SUBSCRIBER_EVENTS.created, subscription);
        });
    }
    getSubscription(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isEnabled();
            this.logger.debug(`Getting subscription`);
            this.logger.trace({ type: "method", method: "getSubscription", id });
            const subscription = this.subscriptions.get(id);
            if (!subscription) {
                const error = utils_1.ERROR.NO_MATCHING_ID.format({
                    context: utils_1.formatMessageContext(this.context),
                    id,
                });
                throw new Error(error.message);
            }
            return subscription;
        });
    }
    deleteSubscription(id, reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isEnabled();
            this.logger.debug(`Deleting subscription`);
            this.logger.trace({ type: "method", method: "deleteSubscription", id, reason });
            const subscription = yield this.getSubscription(id);
            this.subscriptions.delete(id);
            this.topicMap.delete(subscription.topic, id);
            this.events.emit(constants_1.SUBSCRIBER_EVENTS.deleted, Object.assign(Object.assign({}, subscription), { reason }));
        });
    }
    persist() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.relayer.storage.setRelayerSubscriptions(this.context, this.values);
            this.events.emit(constants_1.SUBSCRIBER_EVENTS.sync);
        });
    }
    restore() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const persisted = yield this.relayer.storage.getRelayerSubscriptions(this.context);
                if (typeof persisted === "undefined")
                    return;
                if (!persisted.length)
                    return;
                if (this.subscriptions.size) {
                    const error = utils_1.ERROR.RESTORE_WILL_OVERRIDE.format({
                        context: utils_1.formatMessageContext(this.context),
                    });
                    this.logger.error(error.message);
                    throw new Error(error.message);
                }
                this.cached = persisted;
                this.logger.debug(`Successfully Restored subscriptions for ${utils_1.formatMessageContext(this.context)}`);
                this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
            }
            catch (e) {
                this.logger.debug(`Failed to Restore subscriptions for ${utils_1.formatMessageContext(this.context)}`);
                this.logger.error(e);
            }
        });
    }
    initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.restore();
            yield this.reset();
            yield this.enable();
        });
    }
    isEnabled() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.cached.length)
                return;
            return new Promise(resolve => {
                this.events.once(constants_1.SUBSCRIBER_EVENTS.enabled, () => resolve());
            });
        });
    }
    reset() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.cached.length)
                return;
            yield Promise.all(this.cached.map((subscription) => tslib_1.__awaiter(this, void 0, void 0, function* () { return this.resubscribe(subscription); })));
        });
    }
    resubscribe(subscription) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, relay } = subscription;
            const params = { topic, relay };
            this.pending.set(params.topic, params);
            const id = yield this.rpcSubscribe(params.topic, params.relay);
            yield this.onResubscribe(id, params);
            if (this.ids.includes(subscription.id)) {
                const reason = utils_1.ERROR.RESUBSCRIBED.format({ topic: subscription.topic });
                yield this.deleteSubscription(subscription.id, reason);
            }
        });
    }
    onConnect() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.reset();
            yield this.enable();
        });
    }
    onDisconnect() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.disable();
        });
    }
    checkPending() {
        this.pending.forEach((params) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const id = yield this.rpcSubscribe(params.topic, params.relay);
            yield this.onSubscribe(id, params);
        }));
    }
    registerEventListeners() {
        this.relayer.heartbeat.on(constants_1.HEARTBEAT_EVENTS.pulse, () => {
            this.checkPending();
        });
        this.relayer.provider.on(constants_1.RELAYER_PROVIDER_EVENTS.connect, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.onConnect();
        }));
        this.relayer.provider.on(constants_1.RELAYER_PROVIDER_EVENTS.disconnect, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.onDisconnect();
        }));
        this.events.on(constants_1.SUBSCRIBER_EVENTS.created, (createdEvent) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const eventName = constants_1.SUBSCRIBER_EVENTS.created;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: createdEvent });
            yield this.persist();
        }));
        this.events.on(constants_1.SUBSCRIBER_EVENTS.deleted, (deletedEvent) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const eventName = constants_1.SUBSCRIBER_EVENTS.deleted;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: deletedEvent });
            yield this.persist();
        }));
    }
}
exports.Subscriber = Subscriber;
//# sourceMappingURL=subscriber.js.map