"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Relayer = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const pino_1 = tslib_1.__importDefault(require("pino"));
const keyvaluestorage_1 = tslib_1.__importDefault(require("keyvaluestorage"));
const logger_1 = require("@walletconnect/logger");
const types_1 = require("@walletconnect/types");
const utils_1 = require("@walletconnect/utils");
const jsonrpc_provider_1 = require("@walletconnect/jsonrpc-provider");
const jsonrpc_ws_connection_1 = tslib_1.__importDefault(require("@walletconnect/jsonrpc-ws-connection"));
const jsonrpc_utils_1 = require("@walletconnect/jsonrpc-utils");
const subscriber_1 = require("./subscriber");
const constants_1 = require("../constants");
const history_1 = require("./history");
const storage_1 = require("./storage");
const encoder_1 = require("./encoder");
const heartbeat_1 = require("./heartbeat");
const publisher_1 = require("./publisher");
class Relayer extends types_1.IRelayer {
    constructor(opts) {
        super(opts);
        this.protocol = "irn";
        this.version = 1;
        this.events = new events_1.EventEmitter();
        this.name = constants_1.RELAYER_CONTEXT;
        this.logger =
            typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== "undefined" && typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== "string"
                ? logger_1.generateChildLogger(opts.logger, this.name)
                : pino_1.default(logger_1.getDefaultLoggerOptions({ level: (opts === null || opts === void 0 ? void 0 : opts.logger) || constants_1.RELAYER_DEFAULT_LOGGER }));
        const kvsOptions = Object.assign(Object.assign({}, constants_1.RELAYER_STORAGE_OPTIONS), opts === null || opts === void 0 ? void 0 : opts.keyValueStorageOptions);
        this.storage =
            typeof (opts === null || opts === void 0 ? void 0 : opts.storage) !== "undefined"
                ? opts.storage
                : new storage_1.RelayerStorage(this.logger, (opts === null || opts === void 0 ? void 0 : opts.keyValueStorage) || new keyvaluestorage_1.default(kvsOptions), {
                    protocol: this.protocol,
                    version: this.version,
                    context: this.context,
                });
        this.heartbeat = (opts === null || opts === void 0 ? void 0 : opts.heartbeat) || new heartbeat_1.HeartBeat({ logger: this.logger });
        this.encoder = (opts === null || opts === void 0 ? void 0 : opts.encoder) || new encoder_1.RelayerEncoder();
        const rpcUrl = (opts === null || opts === void 0 ? void 0 : opts.rpcUrl) ||
            utils_1.formatRelayRpcUrl(this.protocol, this.version, constants_1.RELAYER_DEFAULT_RELAY_URL, opts === null || opts === void 0 ? void 0 : opts.projectId);
        this.provider =
            typeof (opts === null || opts === void 0 ? void 0 : opts.relayProvider) !== "string" && typeof (opts === null || opts === void 0 ? void 0 : opts.relayProvider) !== "undefined"
                ? opts === null || opts === void 0 ? void 0 : opts.relayProvider : new jsonrpc_provider_1.JsonRpcProvider(new jsonrpc_ws_connection_1.default(rpcUrl));
        this.history = new history_1.JsonRpcHistory(this.logger, this.storage);
        this.subscriber = new subscriber_1.Subscriber(this, this.logger);
        this.publisher = new publisher_1.Publisher(this, this.logger);
        this.registerEventListeners();
    }
    get context() {
        return logger_1.getLoggerContext(this.logger);
    }
    get connected() {
        return this.provider.connection.connected;
    }
    get connecting() {
        return this.provider.connection.connecting;
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            yield this.history.init();
            yield this.provider.connect();
            yield this.subscriber.init();
            yield this.publisher.init();
        });
    }
    publish(topic, payload, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.publisher.publish(topic, payload, opts);
            yield this.recordPayloadEvent({ topic, payload });
        });
    }
    subscribe(topic, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const id = yield this.subscriber.subscribe(topic, opts);
            return id;
        });
    }
    unsubscribe(topic, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.subscriber.unsubscribe(topic, opts);
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    recordPayloadEvent(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            if (jsonrpc_utils_1.isJsonRpcRequest(payload)) {
                yield this.history.set(topic, payload);
            }
            else {
                yield this.history.resolve(payload);
            }
        });
    }
    shouldIgnorePayloadEvent(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            if (!this.subscriber.topics.includes(topic))
                return true;
            let exists = false;
            try {
                if (jsonrpc_utils_1.isJsonRpcRequest(payload)) {
                    exists = yield this.history.exists(topic, payload.id);
                }
                else {
                    let record;
                    try {
                        record = yield this.history.get(topic, payload.id);
                    }
                    catch (e) {
                    }
                    exists = typeof record !== "undefined" && typeof record.response !== "undefined";
                }
            }
            catch (e) {
            }
            return exists;
        });
    }
    onPayload(payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Incoming Relay Payload`);
            this.logger.trace({ type: "payload", direction: "incoming", payload });
            if (jsonrpc_utils_1.isJsonRpcRequest(payload)) {
                if (!payload.method.endsWith(constants_1.RELAYER_SUBSCRIBER_SUFFIX))
                    return;
                const event = payload.params;
                const { topic, message } = event.data;
                const payloadEvent = {
                    topic,
                    payload: yield this.encoder.decode(topic, message),
                };
                if (yield this.shouldIgnorePayloadEvent(payloadEvent))
                    return;
                this.logger.debug(`Emitting Relayer Payload`);
                this.logger.trace(Object.assign({ type: "event", event: event.id }, payloadEvent));
                this.events.emit(event.id, payloadEvent);
                this.events.emit(constants_1.RELAYER_EVENTS.payload, payloadEvent);
                yield this.acknowledgePayload(payload);
                yield this.recordPayloadEvent(payloadEvent);
            }
        });
    }
    acknowledgePayload(payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = jsonrpc_utils_1.formatJsonRpcResult(payload.id, true);
            yield this.provider.connection.send(response);
        });
    }
    registerEventListeners() {
        this.provider.on(constants_1.RELAYER_PROVIDER_EVENTS.payload, (payload) => this.onPayload(payload));
        this.provider.on(constants_1.RELAYER_PROVIDER_EVENTS.connect, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.events.emit(constants_1.RELAYER_EVENTS.connect);
        }));
        this.provider.on(constants_1.RELAYER_PROVIDER_EVENTS.disconnect, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.events.emit(constants_1.RELAYER_EVENTS.disconnect);
            setTimeout(() => {
                this.provider.connect();
            }, constants_1.RELAYER_RECONNECT_TIMEOUT);
        }));
        this.provider.on(constants_1.RELAYER_PROVIDER_EVENTS.error, e => this.events.emit(constants_1.RELAYER_EVENTS.error, e));
    }
}
exports.Relayer = Relayer;
//# sourceMappingURL=relayer.js.map