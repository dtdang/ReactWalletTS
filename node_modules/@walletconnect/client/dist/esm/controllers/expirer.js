import { EventEmitter } from "events";
import { IExpirer } from "@walletconnect/types";
import { generateChildLogger, getLoggerContext } from "@walletconnect/logger";
import { ERROR, formatMessageContext, toMiliseconds } from "@walletconnect/utils";
import { EXPIRER_CONTEXT, EXPIRER_EVENTS, HEARTBEAT_EVENTS } from "../constants";
export class Expirer extends IExpirer {
    constructor(client, logger) {
        super(client, logger);
        this.client = client;
        this.logger = logger;
        this.expirations = new Map();
        this.events = new EventEmitter();
        this.name = EXPIRER_CONTEXT;
        this.cached = [];
        this.client;
        this.logger = generateChildLogger(logger, this.name);
        this.registerEventListeners();
    }
    get context() {
        return getLoggerContext(this.logger);
    }
    get length() {
        return this.expirations.size;
    }
    get topics() {
        return Array.from(this.expirations.keys());
    }
    get values() {
        return Array.from(this.expirations.values());
    }
    async init() {
        this.logger.trace(`Initialized`);
        await this.initialize();
    }
    async has(topic) {
        try {
            const expiration = this.getExpiration(topic);
            return typeof expiration !== "undefined";
        }
        catch (e) {
            return false;
        }
    }
    async set(topic, expiration) {
        await this.isInitialized();
        this.expirations.set(topic, expiration);
        this.checkExpiry(topic, expiration);
        this.events.emit(EXPIRER_EVENTS.created, {
            topic,
            expiration,
        });
    }
    async get(topic) {
        await this.isInitialized();
        return this.getExpiration(topic);
    }
    async del(topic) {
        await this.isInitialized();
        const expiration = this.getExpiration(topic);
        this.expirations.delete(topic);
        this.events.emit(EXPIRER_EVENTS.deleted, {
            topic,
            expiration,
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    async persist() {
        await this.client.storage.setSequenceStore(this.context, this.values);
        this.events.emit(EXPIRER_EVENTS.sync);
    }
    async restore() {
        try {
            const persisted = await this.client.storage.getSequenceStore(this.context);
            if (typeof persisted === "undefined")
                return;
            if (!persisted.length)
                return;
            if (this.expirations.size) {
                const error = ERROR.RESTORE_WILL_OVERRIDE.format({
                    context: formatMessageContext(this.context),
                });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
            this.cached = persisted;
            this.logger.debug(`Successfully Restored expirations for ${formatMessageContext(this.context)}`);
            this.logger.trace({ type: "method", method: "restore", expirations: this.values });
        }
        catch (e) {
            this.logger.debug(`Failed to Restore expirations for ${formatMessageContext(this.context)}`);
            this.logger.error(e);
        }
    }
    async initialize() {
        await this.restore();
        this.reset();
        this.onInit();
    }
    reset() {
        this.cached.forEach(expiration => this.expirations.set(expiration.topic, expiration));
    }
    onInit() {
        this.cached = [];
        this.events.emit(EXPIRER_EVENTS.init);
    }
    async isInitialized() {
        if (!this.cached.length)
            return;
        return new Promise(resolve => {
            this.events.once(EXPIRER_EVENTS.init, () => resolve());
        });
    }
    getExpiration(topic) {
        const expiration = this.expirations.get(topic);
        if (!expiration) {
            const error = ERROR.NO_MATCHING_ID.format({
                context: formatMessageContext(this.context),
                topic,
            });
            throw new Error(error.message);
        }
        return expiration;
    }
    checkExpiry(topic, expiration) {
        const { expiry } = expiration;
        const msToTimeout = toMiliseconds(expiry) - Date.now();
        if (msToTimeout <= 0)
            this.expire(topic, expiration);
    }
    expire(topic, expiration) {
        this.expirations.delete(topic);
        this.events.emit(EXPIRER_EVENTS.expired, {
            topic,
            expiration,
        });
    }
    checkExpirations() {
        this.expirations.forEach((expiration, topic) => this.checkExpiry(topic, expiration));
    }
    registerEventListeners() {
        this.client.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => this.checkExpirations());
        this.events.on(EXPIRER_EVENTS.created, (createdEvent) => {
            const eventName = EXPIRER_EVENTS.created;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: createdEvent });
            this.persist();
        });
        this.events.on(EXPIRER_EVENTS.expired, (expiredEvent) => {
            const eventName = EXPIRER_EVENTS.expired;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: expiredEvent });
            this.persist();
        });
        this.events.on(EXPIRER_EVENTS.deleted, (deletedEvent) => {
            const eventName = EXPIRER_EVENTS.deleted;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: deletedEvent });
            this.persist();
        });
    }
}
//# sourceMappingURL=expirer.js.map