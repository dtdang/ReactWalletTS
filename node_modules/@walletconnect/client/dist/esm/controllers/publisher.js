import { EventEmitter } from "events";
import { generateChildLogger, getLoggerContext } from "@walletconnect/logger";
import { getRelayProtocolName, getRelayProtocolApi } from "@walletconnect/utils";
import { IEvents } from "@walletconnect/jsonrpc-types";
import { PUBLISHER_CONTEXT, HEARTBEAT_EVENTS, PUBLISHER_DEFAULT_TTL } from "../constants";
export class IPublisher extends IEvents {
    constructor(relayer, logger) {
        super();
        this.relayer = relayer;
        this.logger = logger;
    }
}
export class Publisher extends IPublisher {
    constructor(relayer, logger) {
        super(relayer, logger);
        this.relayer = relayer;
        this.logger = logger;
        this.events = new EventEmitter();
        this.name = PUBLISHER_CONTEXT;
        this.queue = new Map();
        this.relayer = relayer;
        this.logger = generateChildLogger(logger, this.name);
        this.registerEventListeners();
    }
    get context() {
        return getLoggerContext(this.logger);
    }
    async init() {
        this.logger.trace(`Initialized`);
        await this.initialize();
    }
    async publish(topic, payload, opts) {
        this.logger.debug(`Publishing Payload`);
        this.logger.trace({ type: "method", method: "publish", params: { topic, payload, opts } });
        try {
            const ttl = (opts === null || opts === void 0 ? void 0 : opts.ttl) || PUBLISHER_DEFAULT_TTL;
            const relay = getRelayProtocolName(opts);
            const prompt = (opts === null || opts === void 0 ? void 0 : opts.prompt) || false;
            const params = { topic, payload, opts: { ttl, relay, prompt } };
            this.queue.set(payload.id, params);
            const message = await this.relayer.encoder.encode(topic, payload);
            await this.rpcPublish(topic, message, ttl, relay, prompt);
            await this.onPublish(payload.id, params);
            this.logger.debug(`Successfully Published Payload`);
            this.logger.trace({ type: "method", method: "publish", params: { topic, payload, opts } });
        }
        catch (e) {
            this.logger.debug(`Failed to Publish Payload`);
            this.logger.error(e);
            throw e;
        }
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    async initialize() {
    }
    async rpcPublish(topic, message, ttl, relay, prompt) {
        var _a, _b;
        const api = getRelayProtocolApi(relay.protocol);
        const request = {
            method: api.publish,
            params: {
                topic,
                message,
                ttl,
                prompt,
            },
        };
        if (typeof ((_a = request.params) === null || _a === void 0 ? void 0 : _a.prompt) === "undefined") {
            (_b = request.params) === null || _b === void 0 ? true : delete _b.prompt;
        }
        this.logger.debug(`Outgoing Relay Payload`);
        this.logger.trace({ type: "payload", direction: "outgoing", request });
        return this.relayer.provider.request(request);
    }
    async onPublish(id, params) {
        this.queue.delete(id);
    }
    checkQueue() {
        this.queue.forEach(async (params) => {
            const { topic, payload, opts: { ttl, relay }, } = params;
            const message = await this.relayer.encoder.encode(topic, payload);
            await this.rpcPublish(topic, message, ttl, relay);
            await this.onPublish(payload.id, params);
        });
    }
    registerEventListeners() {
        this.relayer.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {
            this.checkQueue();
        });
    }
}
//# sourceMappingURL=publisher.js.map