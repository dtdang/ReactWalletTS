import { generateChildLogger, getLoggerContext } from "@walletconnect/logger";
import { ERROR, mapToObj, objToMap, formatStorageKeyName } from "@walletconnect/utils";
import { STORAGE_CONTEXT, STORAGE_KEYS, STORAGE_VERSION } from "../constants";
export class BaseStorage {
    constructor(logger, keyValueStorage, config) {
        this.logger = logger;
        this.keyValueStorage = keyValueStorage;
        this.config = config;
        this.name = STORAGE_CONTEXT;
        this.version = STORAGE_VERSION;
        this.keyMap = STORAGE_KEYS;
        this.logger = generateChildLogger(logger, this.name);
        this.keyValueStorage = keyValueStorage;
        this.config = config;
    }
    get context() {
        return getLoggerContext(this.logger);
    }
    get prefix() {
        return `${this.config.protocol}@${this.config.version}:${this.config.context}:${this.version}`;
    }
    getStorageKey(context) {
        const name = this.getStorageKeyName(context);
        if (!this.isValidStorageKeyName(name)) {
            const error = ERROR.INVALID_STORAGE_KEY_NAME.format({ name });
            throw new Error(error.message);
        }
        const key = this.prefix + "//" + name;
        return key;
    }
    getStorageKeyName(context) {
        return formatStorageKeyName(context);
    }
    isValidStorageKeyName(name) {
        const validKeys = Object.keys(this.keyMap)
            .map(key => Object.values(this.keyMap[key]))
            .flat();
        return validKeys.includes(name.toLowerCase());
    }
}
export class RelayerStorage extends BaseStorage {
    constructor(logger, keyValueStorage, config) {
        super(logger, keyValueStorage, config);
        this.logger = logger;
        this.keyValueStorage = keyValueStorage;
        this.config = config;
    }
    async setJsonRpcRecords(context, records) {
        const key = this.getStorageKey(context);
        await this.keyValueStorage.setItem(key, records);
    }
    async getJsonRpcRecords(context) {
        const key = this.getStorageKey(context);
        const records = await this.keyValueStorage.getItem(key);
        return records;
    }
    async setRelayerSubscriptions(context, subscriptions) {
        const key = this.getStorageKey(context);
        await this.keyValueStorage.setItem(key, subscriptions);
    }
    async getRelayerSubscriptions(context) {
        const key = this.getStorageKey(context);
        const subscriptions = await this.keyValueStorage.getItem(key);
        return subscriptions;
    }
}
export class Storage extends RelayerStorage {
    constructor(logger, keyValueStorage, config) {
        super(logger, keyValueStorage, config);
        this.logger = logger;
        this.keyValueStorage = keyValueStorage;
        this.config = config;
    }
    async setKeyChain(context, keychain) {
        const key = this.getStorageKey(context);
        await this.keyValueStorage.setItem(key, mapToObj(keychain));
    }
    async getKeyChain(context) {
        const key = this.getStorageKey(context);
        const keychain = await this.keyValueStorage.getItem(key);
        return typeof keychain !== "undefined" ? objToMap(keychain) : undefined;
    }
    async setSequenceStore(context, sequences) {
        const key = this.getStorageKey(context);
        await this.keyValueStorage.setItem(key, sequences);
    }
    async getSequenceStore(context) {
        const key = this.getStorageKey(context);
        const sequences = await this.keyValueStorage.getItem(key);
        return sequences;
    }
    async setExpirations(context, expirations) {
        const key = this.getStorageKey(context);
        await this.keyValueStorage.setItem(key, expirations);
    }
    async getExpirations(context) {
        const key = this.getStorageKey(context);
        const expirations = await this.keyValueStorage.getItem(key);
        return expirations;
    }
}
//# sourceMappingURL=storage.js.map