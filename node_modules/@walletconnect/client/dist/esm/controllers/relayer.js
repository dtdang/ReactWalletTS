import { EventEmitter } from "events";
import pino from "pino";
import KeyValueStorage from "keyvaluestorage";
import { generateChildLogger, getDefaultLoggerOptions, getLoggerContext, } from "@walletconnect/logger";
import { IRelayer, } from "@walletconnect/types";
import { formatRelayRpcUrl } from "@walletconnect/utils";
import { JsonRpcProvider } from "@walletconnect/jsonrpc-provider";
import WsConnection from "@walletconnect/jsonrpc-ws-connection";
import { isJsonRpcRequest, formatJsonRpcResult, } from "@walletconnect/jsonrpc-utils";
import { Subscriber } from "./subscriber";
import { RELAYER_CONTEXT, RELAYER_DEFAULT_LOGGER, RELAYER_EVENTS, RELAYER_PROVIDER_EVENTS, RELAYER_SUBSCRIBER_SUFFIX, RELAYER_RECONNECT_TIMEOUT, RELAYER_STORAGE_OPTIONS, RELAYER_DEFAULT_RELAY_URL, } from "../constants";
import { JsonRpcHistory } from "./history";
import { RelayerStorage } from "./storage";
import { RelayerEncoder } from "./encoder";
import { HeartBeat } from "./heartbeat";
import { Publisher } from "./publisher";
export class Relayer extends IRelayer {
    constructor(opts) {
        super(opts);
        this.protocol = "irn";
        this.version = 1;
        this.events = new EventEmitter();
        this.name = RELAYER_CONTEXT;
        this.logger =
            typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== "undefined" && typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== "string"
                ? generateChildLogger(opts.logger, this.name)
                : pino(getDefaultLoggerOptions({ level: (opts === null || opts === void 0 ? void 0 : opts.logger) || RELAYER_DEFAULT_LOGGER }));
        const kvsOptions = Object.assign(Object.assign({}, RELAYER_STORAGE_OPTIONS), opts === null || opts === void 0 ? void 0 : opts.keyValueStorageOptions);
        this.storage =
            typeof (opts === null || opts === void 0 ? void 0 : opts.storage) !== "undefined"
                ? opts.storage
                : new RelayerStorage(this.logger, (opts === null || opts === void 0 ? void 0 : opts.keyValueStorage) || new KeyValueStorage(kvsOptions), {
                    protocol: this.protocol,
                    version: this.version,
                    context: this.context,
                });
        this.heartbeat = (opts === null || opts === void 0 ? void 0 : opts.heartbeat) || new HeartBeat({ logger: this.logger });
        this.encoder = (opts === null || opts === void 0 ? void 0 : opts.encoder) || new RelayerEncoder();
        const rpcUrl = (opts === null || opts === void 0 ? void 0 : opts.rpcUrl) ||
            formatRelayRpcUrl(this.protocol, this.version, RELAYER_DEFAULT_RELAY_URL, opts === null || opts === void 0 ? void 0 : opts.projectId);
        this.provider =
            typeof (opts === null || opts === void 0 ? void 0 : opts.relayProvider) !== "string" && typeof (opts === null || opts === void 0 ? void 0 : opts.relayProvider) !== "undefined"
                ? opts === null || opts === void 0 ? void 0 : opts.relayProvider : new JsonRpcProvider(new WsConnection(rpcUrl));
        this.history = new JsonRpcHistory(this.logger, this.storage);
        this.subscriber = new Subscriber(this, this.logger);
        this.publisher = new Publisher(this, this.logger);
        this.registerEventListeners();
    }
    get context() {
        return getLoggerContext(this.logger);
    }
    get connected() {
        return this.provider.connection.connected;
    }
    get connecting() {
        return this.provider.connection.connecting;
    }
    async init() {
        this.logger.trace(`Initialized`);
        await this.history.init();
        await this.provider.connect();
        await this.subscriber.init();
        await this.publisher.init();
    }
    async publish(topic, payload, opts) {
        await this.publisher.publish(topic, payload, opts);
        await this.recordPayloadEvent({ topic, payload });
    }
    async subscribe(topic, opts) {
        const id = await this.subscriber.subscribe(topic, opts);
        return id;
    }
    async unsubscribe(topic, opts) {
        await this.subscriber.unsubscribe(topic, opts);
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    async recordPayloadEvent(payloadEvent) {
        const { topic, payload } = payloadEvent;
        if (isJsonRpcRequest(payload)) {
            await this.history.set(topic, payload);
        }
        else {
            await this.history.resolve(payload);
        }
    }
    async shouldIgnorePayloadEvent(payloadEvent) {
        const { topic, payload } = payloadEvent;
        if (!this.subscriber.topics.includes(topic))
            return true;
        let exists = false;
        try {
            if (isJsonRpcRequest(payload)) {
                exists = await this.history.exists(topic, payload.id);
            }
            else {
                let record;
                try {
                    record = await this.history.get(topic, payload.id);
                }
                catch (e) {
                }
                exists = typeof record !== "undefined" && typeof record.response !== "undefined";
            }
        }
        catch (e) {
        }
        return exists;
    }
    async onPayload(payload) {
        this.logger.debug(`Incoming Relay Payload`);
        this.logger.trace({ type: "payload", direction: "incoming", payload });
        if (isJsonRpcRequest(payload)) {
            if (!payload.method.endsWith(RELAYER_SUBSCRIBER_SUFFIX))
                return;
            const event = payload.params;
            const { topic, message } = event.data;
            const payloadEvent = {
                topic,
                payload: await this.encoder.decode(topic, message),
            };
            if (await this.shouldIgnorePayloadEvent(payloadEvent))
                return;
            this.logger.debug(`Emitting Relayer Payload`);
            this.logger.trace(Object.assign({ type: "event", event: event.id }, payloadEvent));
            this.events.emit(event.id, payloadEvent);
            this.events.emit(RELAYER_EVENTS.payload, payloadEvent);
            await this.acknowledgePayload(payload);
            await this.recordPayloadEvent(payloadEvent);
        }
    }
    async acknowledgePayload(payload) {
        const response = formatJsonRpcResult(payload.id, true);
        await this.provider.connection.send(response);
    }
    registerEventListeners() {
        this.provider.on(RELAYER_PROVIDER_EVENTS.payload, (payload) => this.onPayload(payload));
        this.provider.on(RELAYER_PROVIDER_EVENTS.connect, async () => {
            this.events.emit(RELAYER_EVENTS.connect);
        });
        this.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, async () => {
            this.events.emit(RELAYER_EVENTS.disconnect);
            setTimeout(() => {
                this.provider.connect();
            }, RELAYER_RECONNECT_TIMEOUT);
        });
        this.provider.on(RELAYER_PROVIDER_EVENTS.error, e => this.events.emit(RELAYER_EVENTS.error, e));
    }
}
//# sourceMappingURL=relayer.js.map