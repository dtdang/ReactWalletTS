import { Logger } from "pino";
import { IKeyValueStorage, KeyValueStorageOptions } from "keyvaluestorage";
import { JsonRpcResponse, IEvents } from "@walletconnect/jsonrpc-types";
import { IRelayer, RelayerTypes } from "./relayer";
import { ISession, SessionTypes } from "./session";
import { IPairing, PairingTypes } from "./pairing";
import { SignalTypes, AppMetadata, Reason } from "./misc";
import { ICrypto, IKeyChain } from "./crypto";
import { IHeartBeat } from "./heartbeat";
import { IStorage } from "./storage";
import { IEncoder } from "./encoder";
export interface ClientOptions {
    name?: string;
    projectId?: string;
    controller?: boolean;
    metadata?: AppMetadata;
    relayUrl?: string;
    logger?: string | Logger;
    keychain?: IKeyChain;
    storage?: IKeyValueStorage;
    storageOptions?: KeyValueStorageOptions;
}
export declare abstract class IClient extends IEvents {
    readonly protocol = "wc";
    readonly version = 2;
    abstract logger: Logger;
    abstract heartbeat: IHeartBeat;
    abstract crypto: ICrypto;
    abstract encoder: IEncoder;
    abstract storage: IStorage;
    abstract relayer: IRelayer;
    abstract pairing: IPairing;
    abstract session: ISession;
    abstract readonly name: string;
    abstract readonly context: string;
    abstract readonly controller: boolean;
    abstract readonly metadata: AppMetadata | undefined;
    abstract readonly relayUrl: string | undefined;
    abstract readonly projectId: string | undefined;
    constructor(opts?: ClientOptions);
    abstract connect(params: ClientTypes.ConnectParams): Promise<SessionTypes.Settled>;
    abstract pair(params: ClientTypes.PairParams): Promise<PairingTypes.Settled>;
    abstract approve(params: ClientTypes.ApproveParams): Promise<SessionTypes.Settled>;
    abstract reject(params: ClientTypes.RejectParams): Promise<void>;
    abstract update(params: ClientTypes.UpdateParams): Promise<void>;
    abstract upgrade(params: ClientTypes.UpgradeParams): Promise<void>;
    abstract extend(params: ClientTypes.ExtendParams): Promise<void>;
    abstract request(params: ClientTypes.RequestParams): Promise<any>;
    abstract respond(params: ClientTypes.RespondParams): Promise<void>;
    abstract ping(params: ClientTypes.PingParams): Promise<void>;
    abstract notify(params: ClientTypes.NotifyParams): Promise<void>;
    abstract disconnect(params: ClientTypes.DisconnectParams): Promise<void>;
}
export declare namespace ClientTypes {
    interface ConnectParams {
        permissions: SessionTypes.BasePermissions;
        metadata?: AppMetadata;
        relay?: RelayerTypes.ProtocolOptions;
        pairing?: SignalTypes.ParamsPairing;
    }
    interface PairParams {
        uri: string;
    }
    interface ResponseInput {
        state: SessionTypes.State;
        metadata?: AppMetadata;
    }
    interface ApproveParams {
        proposal: SessionTypes.Proposal;
        response: ResponseInput;
    }
    interface RejectParams {
        proposal: SessionTypes.Proposal;
        reason?: Reason;
    }
    type UpdateParams = SessionTypes.UpdateParams;
    type UpgradeParams = SessionTypes.UpgradeParams;
    type ExtendParams = SessionTypes.ExtendParams;
    type RequestParams = SessionTypes.RequestParams;
    interface RespondParams {
        topic: string;
        response: JsonRpcResponse;
    }
    interface PingParams {
        topic: string;
        timeout?: number;
    }
    type NotifyParams = SessionTypes.NotifyParams;
    type DisconnectParams = SessionTypes.DeleteParams;
}
//# sourceMappingURL=client.d.ts.map