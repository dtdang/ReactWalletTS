import { Logger } from "pino";
import { IKeyValueStorage } from "keyvaluestorage";
import { JsonRpcRecord } from "./history";
import { SubscriberTypes } from "./subscriber";
import { Expiration } from "./expirer";
export declare type StorageKeyMap = Record<string, Record<string, string>>;
export interface StorageConfig {
    protocol: string;
    version: number;
    context: string;
}
export declare abstract class IBaseStorage {
    logger: Logger;
    keyValueStorage: IKeyValueStorage;
    config: StorageConfig;
    abstract name: string;
    abstract readonly context: string;
    abstract version: string;
    abstract keyMap: StorageKeyMap;
    abstract prefix: string;
    constructor(logger: Logger, keyValueStorage: IKeyValueStorage, config: StorageConfig);
    abstract getStorageKey(context: string): string;
    abstract getStorageKeyName(context: string): string;
    abstract isValidStorageKeyName(name: string): boolean;
}
export declare abstract class IRelayerStorage extends IBaseStorage {
    logger: Logger;
    keyValueStorage: IKeyValueStorage;
    config: StorageConfig;
    constructor(logger: Logger, keyValueStorage: IKeyValueStorage, config: StorageConfig);
    abstract setJsonRpcRecords(context: string, records: JsonRpcRecord[]): Promise<void>;
    abstract getJsonRpcRecords(context: string): Promise<JsonRpcRecord[] | undefined>;
    abstract setRelayerSubscriptions(context: string, subscriptions: SubscriberTypes.Active[]): Promise<void>;
    abstract getRelayerSubscriptions(context: string): Promise<SubscriberTypes.Active[] | undefined>;
}
export declare abstract class IStorage extends IRelayerStorage {
    logger: Logger;
    keyValueStorage: IKeyValueStorage;
    config: StorageConfig;
    constructor(logger: Logger, keyValueStorage: IKeyValueStorage, config: StorageConfig);
    abstract setKeyChain(context: string, keychain: Map<string, string>): Promise<void>;
    abstract getKeyChain(context: string): Promise<Map<string, string> | undefined>;
    abstract setSequenceStore<Sequence = any>(context: string, sequences: Sequence[]): Promise<void>;
    abstract getSequenceStore<Sequence = any>(context: string): Promise<Sequence[] | undefined>;
    abstract setExpirations(context: string, sequences: Expiration[]): Promise<void>;
    abstract getExpirations(context: string): Promise<Expiration[] | undefined>;
}
//# sourceMappingURL=storage.d.ts.map